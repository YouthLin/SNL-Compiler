# 第二章 词法分析

1. 词法分析概述
2. 正则表达式
3. 有限自动机
4. 词法分析程序的设计与实现

## 2.1. 词法分析概述

### 2.1.1 词法分析的任务

3 个任务

1. 将源程序分隔为单词序列
   ```
   if (position > 10) rate = 3.14 * initial;
    ```
   `if` `(` `position` `>` `10` `)` `rate` `=` `3.14` `*` `initial` `;`
2. 将每个单词表示为自定义数据结构(`Token`)便于后续使用
   `if 关键字` `( 左括号` `position 标识符` `> 大于号` `10 字面整数` `) 右括号`
   `rate 标识符` `= 赋值号` `3.14 字母浮点数` `* 乘号` `initial 标识符` `; 分号`
3. 报告词法错误 如果规定标识符不能 @ 开头，那么
   ```
   if x > 0 @x = z; elsee x = y;
   ```
   `@x` 是词法错误，因为不符合任何的单词构成； `elsee` 不是词法错误，因为它是合法的标识符。

   **思考:** 编译时发现了词法错误，是立即停止好， 还是采取某些措施继续向下分析好?

### 2.1.2 单词分类

- 关键字 `if` `class`
- 标识符 `x` `name`
- 运算符 `+` `-` `&&`
- 格式符 `\t` `\n` ` `
- 分隔符 `(` `,` `;`
- 字面常量 `1` `3.14` `"你好"`

### 2.1.2 Token 结构

一般可以包含两个部分
`Token` -> `TokenType` + `AttributeValue`  
单词种类 + 值(单词的语义信息)

**练习：** 按照前例，写出下例单词的 Token 表示

```
int main() { printf("Hello, World!");}
```

```
bool prime(int n) { // This is comment
    int j;
    for ( j = n/2; j >= 2; j-- )
        if ( n % j == 0 ) return false;
    return true;
}
```

**思考:** 制表符、回车、换行、空格等格式符需要表示 成Token结构吗?程序中的注释呢?

## 2.2. 正则表达式

### 2.2.1 什么是正则表达式

- **字母表** 符号的非空有穷集合，记为 Σ(读作 sigma), 其中的符号称为字母或符号
    - 二进制字母表 {0,1}
    - 十进制字母表 {0,1,2,3,4,5,6,7,8,9}
    - ASCII
    - Unicode
- **符号串** 字母表中的符号组成的有穷序列，常用 α β γ 表示
    - 二进制符号串: 1001
    - C 语言符号串：`#include “stdio.h” void main(){printf(“Hello!”);}`
    - 特例：空串，不包含任何符号的串，常记为 ε(/'epsɪlɒn/艾普西龙). 空串 ε 不是空集 Φ(/faɪ/)
- **符号串的长度** 符号串 α 的长度用 |α| 表示
- **符号串的联接** 符号串 α β 的联接用 α*β 表示，也可以直接写作 αβ
- **符号串集** 符号串的集合，一般记为 A, B, C
- **符号串集的乘积** A={α<sub>i</sub> | i=1,2,...,n}, B={β<sub>i</sub> | i=1,2,,...,m} 则乘积 AB={αβ | α∈A, β∈B}
  ```
  令 A = {abc, 123} B = {e,f,g}
  则 AB = {abce, abcf, abcg, 123e, 123f, 123g}
  ```
- **符号串集的方幂** 幂次 i 是非负整数 A<sup>i</sup>. A<sup>0</sup> = {ε}
- **符号串集的正闭包** 记为 A<sup>+</sup> = ∪A<sup>i</sup>, i=1,2,3,...
  <pre>
  记 A = {ab}
  则 A<sup>+</sup> = {ab, abab, ababab, abababab, ...}

  记 B = {a, c}
  则 B<sup>+</sup> = {a, c, aa, ac, ca, cc, aaa, aca, caa, cca, aac, acc, cac, ccc, ...}
  </pre>
- **符号串集的星闭包** 记为 A<sup>\*</sup> = ∪A<sup>i</sup>, i=0,1,2,3,... 
  即 A<sup>0</sup> ∪ A<sup>+</sup>. 也称为 A 的自反闭包（也称 Kleene 闭包）
  <pre>
  A = {ab}
  A<sup>*</sup> = {ε, ab, abab, ababab, abababab, ...}

  B = {a, c}
  B<sup>*</sup> = {ε, a, c, aa, ac, ca, cc, aaa, aca, caa, cca, aac, acc, cac, ccc, ...}
  </pre>

- **正则表达式的形式定义**
  - 空集 Φ 是 RE
  - 空串 ε 是 RE
  - 字母表 Σ 中的符号 c 是 RE
  - 若 A, B 都是 RE, 则 A|B 是 RE, AB 是 RE, A<sup>*</sup> 是 RE

> | 读作或，我们熟知的正则表达式还有 A+ 的概念，上面没有包含，其实就是 AA* (AA*，联接操作，可以省略联接操作符)

- **正则表达式定义的语言**
  字母表 Σ 上的一个正则表达式 r 定义了 Σ 上的一个字符串集合，称为 r 定义的语言，记为 L(r), 也称为正则集
  
  | r | L(r) |
  |---|------|
  | Φ |   Φ  |
  | ε | {ε}  |
  | c | {c}  |
  | A | L(A)  |
  | A &vert; B | L(A) ∪ L(B)   |
  | AB | L(A)L(B)   |
  | A<sup>*</sup> | L(A)<sup>*</sup>   |
  
  <pre>
  r=ab* => L(r)=L(a)L(b*)={a}{ε,b,bb,bbb,...}={a, ab, abb, abbb,...}
  r=a*bc* => L(r)=L(a*)L(b)L(c*)={ε,a,aa,aaa,...}{b}{ε,c,cc,ccc,...}={b,ab,aab,aaab,...,bc,bcc,bccc,...,abc,aabcc,...}
  r=(a|b)*c => L(r)=L((a|b)*)L(c)=L((a|b))<sup>*</sup>L(c)
               =(L(a) ∪ L(b))<sup>*</sup>L(c)={a,b}*{c} 
               = {ε,a,b,aa,ab,ba,bb,...}{c} 
               = {c, ac, bc, aac, abc, bac, bbc,...}
  r=(0|1)(0|1)* => L(r) = L((0|1))L((0|1))* = [L(0)∪L(1)][L(0)∪L(1)]*
                 = {0,1}{0,1}* = {0,1}{ε,0,1,00,01,11,10,000,010,110,100,001,011,111,101,...}
                 = {0,1,00,10,01,11,000,100,011,111,...}
  </pre>
- **正则表达式的等价** 若两个正则表达式 r,s 定义的语言相同，则等价。  
  如 (a|b)* 与 (b|a)* 等价
- **正则表达式的性质** 
  ```
  r|s = s|r
  r|(s|t) = (r|s)|t
  r(st) = (rs)t
  r(s|t) = rs|rt
  (r|s)t = rt|st
  r** = r*
  rε = εr = r
  ```

### 2.2.2 正则表达式的应用
- 例 1
  电子邮件地址用正则表达式表示
  如 zhangsan@jlu.edu.cn zs1@qq.com
  ```
  字母表 Σ = {a-zA-Z0-9@.}
  Names = (Letter | Digit)(Letter | Digit)*
  Address = Names@(Names. | ε) Names.Names
  ```
- 例 2
  用于定义编程语言中的单词
  ```
  关键字：if, int, class...
  标识符：(Letter)(Letter|Digit)*
  整形常量：(1-9)(0-9)*|0
  ```
### 2.2.3 正则定义
给正则表达式起个名字，简写
```
Letter = A-Za-z
Digit = 0-9
```
### 2.2.4 正则表达式的局限性
不能定义以下两种结构的语言
1. 对称结构 A={ a<sup>n</sup>ba<sup>n</sup> | n>0 }
2. 嵌套结构 (略)

## 2.3. 有限自动机
### 2.3.1 非确定有限自动机
非确定有限自动机 NFA 是一个五元祖(S,Σ,f,S<sub>0</sub>,Z), 其中  
- S 是有限状态集，不能为空
- Σ 是有穷字母表，可以为空
- f 是状态转移函数 f: S * Σ∪{ε} -> 2<sup>S</sup>
- S<sub>0</sub> 是初始状态集, S<sub>0</sub> ⊆ S, 不能为空
- Z 是终止状态集，Z ⊆ S, 可以为空

示例 
todo
```mermaid
graph TD;
  A-->B;
  A-->C;
  B-->D;
  C-->D;
```

### 2.3.2 确定有限自动机
### 2.3.3 有限自动机与正则表达式

## 2.4. 词法分析程序的设计与实现
